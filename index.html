import '../css/styles.css';
import Chart from 'chart.js/auto';

class SolanaMoonDashboard {
    constructor() {
        this.solanaConnection = null;
        this.wallet = null;
        this.priceChart = null;
        this.activityChart = null;
        this.currentFilter = 'all';
        this.memecoins = [];
        this.priceHistory = [];
        this.audioEnabled = true; // Start with audio enabled
        this.currentAudioIndex = 0;
        this.audioTracks = [];
        this.init();
    }

    async init() {
        await this.setupMedia();
        this.setupEventListeners();
        this.setupCharts();
        await this.loadSolanaData();
        await this.loadMemecoinData();
        this.startDataRefresh();
        this.showMemeMessages();
        // Start audio immediately - no delay
        this.enableAudio();
    }

    async setupMedia() {
        // Setup background video
        const video = document.querySelector('.background-video');
        if (video) {
            video.addEventListener('loadeddata', () => {
                console.log('üé¨ Background video loaded!');
            });
            video.addEventListener('error', (e) => {
                console.error('Video loading error:', e);
            });
        }

        // Setup audio tracks with MAXIMUM volume + gain
        this.audioTracks = [
            document.getElementById('backgroundAudio1'),
            document.getElementById('backgroundAudio2')
        ];

        // Wait for audio to load with maximum volume
        await Promise.all(this.audioTracks.map(audio => {
            return new Promise((resolve) => {
                if (audio) {
                    audio.volume = 1.0; // Maximum volume (100%)
                    // Try to boost audio further with gain if supported
                    if (window.AudioContext || window.webkitAudioContext) {
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const source = audioContext.createMediaElementSource(audio);
                            const gainNode = audioContext.createGain();
                            gainNode.gain.value = 2.0; // Double the gain!
                            source.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                        } catch (e) {
                            console.log('Audio gain boost not supported:', e);
                        }
                    }
                    audio.addEventListener('canplaythrough', resolve, { once: true });
                    audio.addEventListener('ended', () => this.playNextTrack());
                    audio.load();
                } else {
                    resolve();
                }
            });
        }));

        console.log('üéµ Audio tracks loaded at MAXIMUM volume with BOOST!');
    }

    setupEventListeners() {
        const connectBtn = document.getElementById('connectWallet');
        connectBtn.addEventListener('click', () => this.connectWallet());

        const audioBtn = document.getElementById('audioToggle');
        audioBtn.addEventListener('click', () => this.toggleAudio());

        // Set initial audio button state - already ON
        audioBtn.textContent = 'üîä SOUND ON';
        audioBtn.classList.remove('muted');

        // Memecoin filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                this.currentFilter = e.target.dataset.filter;
                this.renderMemecoinTable();
            });
        });

        // Force audio to start on any user interaction (browser requirement fallback)
        document.addEventListener('click', () => {
            if (this.audioEnabled && this.audioTracks[this.currentAudioIndex]) {
                const currentAudio = this.audioTracks[this.currentAudioIndex];
                if (currentAudio.paused) {
                    this.playCurrentTrack();
                }
            }
        }, { once: true });

        // Download blackpaper button
        const downloadBtn = document.getElementById('downloadBlackpaper');
        downloadBtn.addEventListener('click', () => this.downloadBlackpaper());
    }

    async connectWallet() {
        try {
            if (window.solana && window.solana.isPhantom) {
                const response = await window.solana.connect();
                this.wallet = response.publicKey.toString();
                
                document.getElementById('connectWallet').classList.add('hidden');
                document.getElementById('walletInfo').classList.remove('hidden');
                document.getElementById('walletAddress').textContent = 
                    `${this.wallet.slice(0, 4)}...${this.wallet.slice(-4)}`;
                
                await this.loadWalletBalance();
                this.showSuccessMessage('üöÄ WALLET CONNECTED! TO THE MOON! üåô');
            } else {
                alert('üíé Please install Phantom Wallet to connect! üíé');
            }
        } catch (error) {
            console.error('Wallet connection failed:', error);
            alert('‚ùå Connection failed. Try again, diamond hands! üíéüôå');
        }
    }

    async loadWalletBalance() {
        try {
            // Simulate SOL balance (replace with actual Solana RPC call)
            const mockBalance = (Math.random() * 100).toFixed(2);
            document.getElementById('solBalance').textContent = `${mockBalance} SOL`;
        } catch (error) {
            console.error('Failed to load balance:', error);
        }
    }

    async loadSolanaData() {
        try {
            await Promise.all([
                this.updatePrice(),
                this.updateNetworkStats()
            ]);
        } catch (error) {
            console.error('Failed to load Solana data:', error);
            this.showError('Failed to load Solana data');
        }
    }

    async updatePrice() {
        try {
            // Use Jupiter API for more reliable Solana price data
            const jupiterResponse = await fetch('https://price.jup.ag/v4/price?ids=So11111111111111111111111111111111111111112');
            const jupiterData = await jupiterResponse.json();
            
            if (jupiterData.data && jupiterData.data.So11111111111111111111111111111111111111112) {
                const solData = jupiterData.data.So11111111111111111111111111111111111111112;
                const price = solData.price;
                
                // Get 24h change from CoinGecko as backup
                const cgResponse = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd&include_24hr_change=true');
                const cgData = await cgResponse.json();
                const change24h = cgData.solana ? cgData.solana.usd_24h_change : 0;
                
                document.getElementById('solPrice').textContent = `$${price.toFixed(2)}`;
                const changeElement = document.getElementById('priceChange');
                changeElement.textContent = `${change24h > 0 ? '+' : ''}${change24h.toFixed(2)}%`;
                changeElement.style.color = change24h > 0 ? '#00ff88' : '#ff4444';
                
                // Get 3 days of price history from CoinGecko
                const historyResponse = await fetch('https://api.coingecko.com/api/v3/coins/solana/market_chart?vs_currency=usd&days=3&interval=hourly');
                const historyData = await historyResponse.json();
                
                if (historyData.prices) {
                    this.priceHistory = historyData.prices.map(price => price[1]);
                    this.updatePriceChart();
                }
            }
        } catch (error) {
            console.error('Failed to update price:', error);
            // Fallback to mock 3-day data
            this.generateMock3DayData();
        }
    }

    generateMock3DayData() {
        const basePrice = 150;
        this.priceHistory = [];
        
        for (let i = 0; i < 72; i++) { // 72 hours = 3 days
            const variation = (Math.random() - 0.5) * 20;
            const price = basePrice + variation + Math.sin(i / 12) * 10;
            this.priceHistory.push(price);
        }
        
        this.updatePriceChart();
        document.getElementById('solPrice').textContent = `$${this.priceHistory[this.priceHistory.length - 1].toFixed(2)}`;
    }

    async updateNetworkStats() {
        try {
            // Fetch real Solana network stats
            const response = await fetch('https://api.mainnet-beta.solana.com', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getEpochInfo'
                })
            });
            
            const data = await response.json();
            if (data.result) {
                document.getElementById('currentEpoch').textContent = data.result.epoch;
            }

            // Mock TPS and validators (real-time APIs are limited)
            document.getElementById('networkTps').textContent = Math.floor(Math.random() * 5000 + 2000);
            document.getElementById('validators').textContent = Math.floor(Math.random() * 100 + 1800);
            
        } catch (error) {
            console.error('Failed to update network stats:', error);
            // Fallback to mock data
            document.getElementById('networkTps').textContent = Math.floor(Math.random() * 5000 + 2000);
            document.getElementById('validators').textContent = Math.floor(Math.random() * 100 + 1800);
            document.getElementById('currentEpoch').textContent = Math.floor(Math.random() * 10 + 450);
        }
    }

    async loadMemecoinData() {
        try {
            this.showLoading();
            
            // Combine data from multiple sources
            const [pumpfunData, raydiumData] = await Promise.all([
                this.fetchPumpfunData(),
                this.fetchRaydiumData()
            ]);

            this.memecoins = [...pumpfunData, ...raydiumData];
            this.renderMemecoinTable();
            
        } catch (error) {
            console.error('Failed to load memecoin data:', error);
            this.showError('Failed to load memecoin data');
            // Fallback to mock data
            this.loadMockMemecoinData();
        }
    }

    async fetchPumpfunData() {
        try {
            // Enhanced mock data with EPIC meme names
            const epicMemeNames = [
                'PEPE PRESIDENT 2024', 'MOON LAMBO ROCKET', 'DIAMOND HANDS FOREVER', 
                'HODL TILL VALHALLA', 'DOGE TO ANDROMEDA', 'WEN MOON CAPTAIN',
                'CHAD THUNDER BULL', 'GIGACHAD TOKEN', 'BASED APE SOCIETY',
                'SIGMA GRINDSET COIN', 'TENDIES INCOMING', 'PUMP MY BAGS',
                'REKT RECOVERY FUND', 'FOMO KING SUPREME', 'YOLO SWAG MONEY',
                'NUMBER GO UP ONLY', 'LINE GOES BRRRRR', 'MONEY PRINTER GO',
                'STONKS TO JUPITER', 'GAINS GOBLIN GANG'
            ];
            
            const pumpfunCoins = [];
            
            for (let i = 0; i < 12; i++) {
                pumpfunCoins.push({
                    symbol: this.generateMemeTicker(),
                    name: epicMemeNames[i] || `Epic Meme ${i + 1}`,
                    price: Math.random() * 0.05,
                    change24h: Math.random() * 800 - 100, // More extreme gains/losses
                    marketCap: Math.random() * 100000000,
                    volume: Math.random() * 25000000,
                    platform: 'pumpfun',
                    launched: new Date(Date.now() - Math.random() * 86400000 * 3)
                });
            }
            
            return pumpfunCoins;
        } catch (error) {
            console.error('Pumpfun API error:', error);
            return [];
        }
    }

    async fetchRaydiumData() {
        try {
            // Try real Raydium API first
            const response = await fetch('https://api.raydium.io/v2/main/pairs');
            const data = await response.json();
            
            if (data && Array.isArray(data)) {
                const recent = data
                    .filter(pair => {
                        const created = new Date(pair.createTime);
                        const now = new Date();
                        return (now - created) < 259200000; // 3 days
                    })
                    .slice(0, 8)
                    .map(pair => ({
                        symbol: pair.baseSymbol || this.generateMemeTicker(),
                        name: pair.baseName || this.generateEpicName(),
                        price: parseFloat(pair.price) || Math.random() * 0.2,
                        change24h: parseFloat(pair.change24h) || (Math.random() * 400 - 75),
                        marketCap: parseFloat(pair.marketCap) || Math.random() * 50000000,
                        volume: parseFloat(pair.volume24h) || Math.random() * 15000000,
                        platform: 'raydium',
                        launched: new Date(pair.createTime || Date.now() - Math.random() * 259200000)
                    }));
                
                return recent;
            }
        } catch (error) {
            console.error('Raydium API error:', error);
        }
        
        // Enhanced fallback with EPIC Raydium names
        const epicRaydiumNames = [
            'SOLANA SPEED DEMON', 'DEX MASTER CHIEF', 'LIQUIDITY LEGEND',
            'SWAP KING KONG', 'AMM ATOMIC BOMB', 'YIELD FARMER PRO',
            'FLASH LOAN FLASH', 'ARBITRAGE ALPHA', 'WHALE HUNTER X',
            'SLIPPAGE SLAYER', 'GAS FEE GOBLIN', 'MEV BOT KILLER'
        ];
        
        const raydiumCoins = [];
        
        for (let i = 0; i < 10; i++) {
            raydiumCoins.push({
                symbol: this.generateMemeTicker(),
                name: epicRaydiumNames[i] || `Raydium Beast ${i + 1}`,
                price: Math.random() * 1.0,
                change24h: Math.random() * 600 - 150,
                marketCap: Math.random() * 200000000,
                volume: Math.random() * 50000000,
                platform: 'raydium',
                launched: new Date(Date.now() - Math.random() * 259200000)
            });
        }
        
        return raydiumCoins;
    }

    generateMemeTicker() {
        const prefixes = ['MOON', 'PEPE', 'DOGE', 'CHAD', 'BASED', 'SIGMA', 'ALPHA', 'BULL', 'BEAR', 'APE'];
        const suffixes = ['X', 'INU', 'COIN', 'TOKEN', '2024', '100X', 'MOON', 'MARS', 'PLUTO', 'GALAXY'];
        
        const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
        const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
        const number = Math.floor(Math.random() * 999) + 1;
        
        return `${prefix}${number}${suffix}`;
    }

    generateEpicName() {
        const adjectives = ['LEGENDARY', 'EPIC', 'ULTIMATE', 'SUPREME', 'MEGA', 'ULTRA', 'SUPER', 'HYPER'];
        const nouns = ['MOONSHOT', 'ROCKET', 'DIAMOND', 'GOLDEN', 'PLATINUM', 'COSMIC', 'GALACTIC', 'QUANTUM'];
        const endings = ['PROTOCOL', 'NETWORK', 'ECOSYSTEM', 'FINANCE', 'DEFI', 'TOKEN', 'COIN', 'PROJECT'];
        
        const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
        const noun = nouns[Math.floor(Math.random() * nouns.length)];
        const ending = endings[Math.floor(Math.random() * endings.length)];
        
        return `${adj} ${noun} ${ending}`;
    }

    updatePriceChart() {
        if (this.priceChart && this.priceHistory.length > 0) {
            // Create labels for 3 days (72 hours)
            const labels = this.priceHistory.map((_, i) => {
                const hoursAgo = this.priceHistory.length - 1 - i;
                if (hoursAgo === 0) return 'Now';
                if (hoursAgo < 24) return `${hoursAgo}h ago`;
                const daysAgo = Math.floor(hoursAgo / 24);
                const remainingHours = hoursAgo % 24;
                return `${daysAgo}d ${remainingHours}h ago`;
            }).reverse();
            
            this.priceChart.data.datasets[0].data = this.priceHistory;
            this.priceChart.data.labels = labels;
            this.priceChart.update('none');
        }
    }

    showLoading() {
        const tbody = document.getElementById('memecoinTableBody');
        tbody.innerHTML = '<tr><td colspan="8" class="loading">üöÄ Loading fresh memecoins... TO THE MOON! üåô</td></tr>';
    }

    showError(message) {
        const tbody = document.getElementById('memecoinTableBody');
        tbody.innerHTML = `<tr><td colspan="8" class="error">‚ùå ${message}</td></tr>`;
    }

    setupCharts() {
        this.setupPriceChart();
        this.setupActivityChart();
    }

    setupPriceChart() {
        const ctx = document.getElementById('priceChart').getContext('2d');
        
        this.priceChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'SOL Price (USD) - Last 3 Days',
                    data: [],
                    borderColor: '#00ff88',
                    backgroundColor: 'rgba(0, 255, 136, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#00ff88',
                        bodyColor: '#fff',
                        borderColor: '#00ff88',
                        borderWidth: 1
                    }
                },
                scales: {
                    x: {
                        display: true,
                        ticks: { 
                            color: '#00ff88', 
                            font: { size: 10 },
                            maxTicksLimit: 8,
                            maxRotation: 0
                        },
                        grid: { 
                            color: 'rgba(0, 255, 136, 0.2)',
                            display: true
                        }
                    },
                    y: {
                        display: true,
                        ticks: { 
                            color: '#00ff88', 
                            font: { size: 10 },
                            callback: function(value) {
                                return '$' + value.toFixed(0);
                            }
                        },
                        grid: { 
                            color: 'rgba(0, 255, 136, 0.2)',
                            display: true
                        }
                    }
                }
            }
        });
    }

    setupActivityChart() {
        const ctx = document.getElementById('activityChart').getContext('2d');
        const mockActivityData = Array.from({length: 12}, () => Math.random() * 5000 + 1000);
        
        this.activityChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: Array.from({length: 12}, (_, i) => `${i * 2}:00`),
                datasets: [{
                    label: 'TPS',
                    data: mockActivityData,
                    backgroundColor: 'rgba(255, 0, 255, 0.6)',
                    borderColor: '#ff00ff',
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#ff00ff',
                        bodyColor: '#fff',
                        borderColor: '#ff00ff',
                        borderWidth: 1
                    }
                },
                scales: {
                    x: {
                        display: true,
                        ticks: { 
                            color: '#ff00ff', 
                            font: { size: 10 },
                            maxRotation: 0
                        },
                        grid: { 
                            color: 'rgba(255, 0, 255, 0.2)',
                            display: true
                        }
                    },
                    y: {
                        display: true,
                        ticks: { 
                            color: '#ff00ff', 
                            font: { size: 10 },
                            callback: function(value) {
                                return value.toFixed(0);
                            }
                        },
                        grid: { 
                            color: 'rgba(255, 0, 255, 0.2)',
                            display: true
                        }
                    }
                }
            }
        });
    }

    renderMemecoinTable() {
        const tbody = document.getElementById('memecoinTableBody');
        let filteredCoins = this.memecoins;

        if (this.currentFilter !== 'all') {
            filteredCoins = this.memecoins.filter(coin => coin.platform === this.currentFilter);
        }

        tbody.innerHTML = filteredCoins.map(coin => `
            <tr>
                <td>
                    <div class="token-info">
                        <div class="token-logo">${coin.symbol.charAt(0)}</div>
                        <span>${coin.symbol}</span>
                    </div>
                </td>
                <td>${coin.name}</td>
                <td>$${coin.price.toFixed(6)}</td>
                <td class="${coin.change24h > 0 ? 'price-positive' : 'price-negative'}">
                    ${coin.change24h > 0 ? '+' : ''}${coin.change24h.toFixed(1)}%
                </td>
                <td>$${this.formatNumber(coin.marketCap)}</td>
                <td>$${this.formatNumber(coin.volume)}</td>
                <td>
                    <span class="platform-badge platform-${coin.platform}">
                        ${coin.platform.toUpperCase()}
                    </span>
                </td>
                <td>
                    <button class="moon-btn" onclick="alert('üöÄ TO THE MOON! üåô')">
                        üöÄ MOON
                    </button>
                </td>
            </tr>
        `).join('');
    }

    formatNumber(num) {
        if (num >= 1000000) {
            return (num / 1000000).toFixed(1) + 'M';
        } else if (num >= 1000) {
            return (num / 1000).toFixed(1) + 'K';
        }
        return num.toString();
    }

    startDataRefresh() {
        // Refresh price more frequently
        setInterval(() => {
            this.updatePrice();
        }, 60000); // Every minute

        // Refresh network stats
        setInterval(() => {
            this.updateNetworkStats();
        }, 120000); // Every 2 minutes

        // Refresh memecoin data
        setInterval(() => {
            this.loadMemecoinData();
        }, 300000); // Every 5 minutes
    }

    showMemeMessages() {
        const messages = [
            'üöÄ SOLANA TO THE MOON! üåô',
            'üíé DIAMOND HANDS ACTIVATED! üíé',
            '‚ö° LIGHTNING FAST TRANSACTIONS! ‚ö°',
            'üî• THIS IS THE WAY! üî•',
            'üéµ VIBING TO THE BEAT! üéµ'
        ];

        let messageIndex = 0;
        setInterval(() => {
            console.log(messages[messageIndex]);
            messageIndex = (messageIndex + 1) % messages.length;
        }, 5000);
    }

    toggleAudio() {
        const audioBtn = document.getElementById('audioToggle');
        
        if (this.audioEnabled) {
            this.disableAudio();
            audioBtn.textContent = 'üîá SOUND OFF';
            audioBtn.classList.add('muted');
        } else {
            this.enableAudio();
            audioBtn.textContent = 'üîä SOUND ON';
            audioBtn.classList.remove('muted');
        }
    }

    enableAudio() {
        this.audioEnabled = true;
        // Try to play immediately
        setTimeout(() => {
            this.playCurrentTrack();
        }, 100); // Very short delay to ensure setup is complete
        console.log('üöÄ AUDIO TO THE MOON AT MAXIMUM VOLUME! üéµ');
    }

    disableAudio() {
        this.audioEnabled = false;
        this.audioTracks.forEach(audio => {
            if (audio) {
                audio.pause();
                audio.currentTime = 0;
            }
        });
    }

    playCurrentTrack() {
        if (!this.audioEnabled || !this.audioTracks[this.currentAudioIndex]) return;

        const currentAudio = this.audioTracks[this.currentAudioIndex];
        // MAXIMUM volume enforcement
        currentAudio.volume = 1.0;
        
        currentAudio.play().then(() => {
            console.log(`üéµ Playing track ${this.currentAudioIndex + 1} at MAXIMUM VOLUME WITH BOOST!`);
        }).catch(error => {
            console.log('Audio play failed, will retry on user interaction:', error);
        });
    }

    playNextTrack() {
        if (!this.audioEnabled) return;

        this.currentAudioIndex = (this.currentAudioIndex + 1) % this.audioTracks.length;
        console.log(`üéµ Switching to track ${this.currentAudioIndex + 1}`);
        setTimeout(() => {
            this.playCurrentTrack();
        }, 500); // Shorter gap between tracks
    }

    showSuccessMessage(message) {
        // Create a temporary success message
        const successDiv = document.createElement('div');
        successDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 136, 0.9);
            color: #000;
            padding: 2rem;
            border-radius: 10px;
            font-family: Orbitron;
            font-weight: 900;
            font-size: 1.5rem;
            z-index: 1000;
            animation: pulse 1s infinite;
        `;
        successDiv.textContent = message;
        document.body.appendChild(successDiv);

        setTimeout(() => {
            document.body.removeChild(successDiv);
        }, 3000);
    }

    downloadBlackpaper() {
        // Simulate blackpaper download
        const link = document.createElement('a');
        link.href = '/path/to/blackpaper.pdf'; // Update with actual path
        link.download = 'SolanaMoon_Blackpaper.pdf';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        this.showSuccessMessage('üì• Downloading Blackpaper... Check your browser\'s download section! üìÑ');
    }
}

// Initialize the dashboard when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new SolanaMoonDashboard();
});